# Epic 11: My Community - Firestore Schema Documentation

## Overview

This document describes the Firestore data model for the "My Community" social graph system. The friendship system serves as the foundation for user relationships in the PlayWithMe app.

## Collection: `/friendships/{friendshipId}`

The `friendships` collection stores bidirectional friendship relationships between users.

### Schema

```javascript
{
  "initiatorId": string,        // User ID who sent the friend request
  "recipientId": string,        // User ID who received the friend request
  "status": "pending" | "accepted" | "declined",
  "createdAt": Timestamp,       // When the friendship request was created
  "updatedAt": Timestamp,       // Last time the friendship was modified
  "initiatorName": string,      // Denormalized display name of initiator
  "recipientName": string       // Denormalized display name of recipient
}
```

### Field Descriptions

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `initiatorId` | string | Yes | UID of the user who initiated the friend request |
| `recipientId` | string | Yes | UID of the user who received the friend request |
| `status` | enum | Yes | Current status: `pending`, `accepted`, or `declined` |
| `createdAt` | Timestamp | Yes | When the friend request was created (set by server) |
| `updatedAt` | Timestamp | Yes | Last modification time (set by server on updates) |
| `initiatorName` | string | Yes | Display name of initiator (denormalized for UI/notifications) |
| `recipientName` | string | Yes | Display name of recipient (denormalized for UI/notifications) |

### Status Transitions

```
pending → accepted   ✅ Valid
pending → declined   ✅ Valid
accepted → declined  ❌ Invalid (status is immutable once accepted)
declined → accepted  ❌ Invalid (must create new friendship request)
declined → pending   ❌ Invalid (must create new friendship request)
```

**Rules:**
- A friendship can transition from `pending` to `accepted`
- A friendship can transition from `pending` to `declined`
- Once a friendship is `accepted` or `declined`, it cannot change status
- To "retry" a declined friendship, delete the old document and create a new one

### Document ID Strategy

- **Document IDs**: Auto-generated by Firestore using `addDoc()` or `.doc()`
- **Why**: Simplifies queries and prevents collisions
- **Not used**: Composite keys (e.g., `userId1_userId2`) - these create unnecessary complexity

### Duplicate Prevention

Before creating a friendship, check for existing friendships in **both directions**:

```typescript
// Check if friendship already exists
const existingFriendship = await db.collection('friendships')
  .where('initiatorId', 'in', [userA, userB])
  .where('recipientId', 'in', [userA, userB])
  .get();

if (!existingFriendship.empty) {
  throw new Error('Friendship already exists');
}
```

**Important**: A friendship between User A and User B can exist in either direction:
- `initiatorId = A, recipientId = B`, OR
- `initiatorId = B, recipientId = A`

Both represent the same logical friendship.

### Denormalized Data

The `initiatorName` and `recipientName` fields are denormalized for performance:

**Benefits:**
- Avoids JOINs when displaying friend lists
- Reduces Firestore reads (no need to fetch user documents)
- Faster UI rendering

**Maintenance:**
- Updated via Cloud Function trigger when a user changes their `displayName`
- See Story 11.3 for trigger implementation

**Trade-off:**
- Slightly stale data if user changes name (acceptable for this use case)
- Consistent data via triggers ensures eventual consistency

## Firestore Indexes

The following composite indexes are required for efficient querying:

### Index 1: Query friendships by initiator and status

```json
{
  "collectionGroup": "friendships",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "initiatorId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

**Use case**: Get all pending/accepted friend requests **sent by** a user
```dart
final sentRequests = await friendshipsRef
  .where('initiatorId', isEqualTo: currentUserId)
  .where('status', isEqualTo: 'pending')
  .get();
```

### Index 2: Query friendships by recipient and status

```json
{
  "collectionGroup": "friendships",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "recipientId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

**Use case**: Get all pending friend requests **received by** a user
```dart
final receivedRequests = await friendshipsRef
  .where('recipientId', isEqualTo: currentUserId)
  .where('status', isEqualTo: 'pending')
  .get();
```

### Index 3: Query friendships by creation date

```json
{
  "collectionGroup": "friendships",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

**Use case**: Get recent friendships (admin/analytics)
```dart
final recentFriendships = await friendshipsRef
  .orderBy('createdAt', descending: true)
  .limit(20)
  .get();
```

## Security Considerations

### Firestore Rules

The Firestore security rules for friendships enforce:

1. **Authentication required**: Only authenticated users can read/write friendships
2. **Ownership validation**: Users can only modify friendships they're involved in
3. **Status immutability**: Once accepted/declined, status cannot be changed
4. **Creation validation**: Only initiator can create with `pending` status

See Story 11.7 for complete security rules implementation.

### Cloud Functions

All friendship operations (create, accept, decline) are handled via Cloud Functions:

**Benefits:**
- Server-side validation
- Consistent business logic
- Duplicate prevention
- Trigger notifications

See Story 11.2 for Cloud Functions implementation.

## Query Patterns

### Get all friends (accepted friendships) for a user

```dart
// Get friendships where user is initiator
final asFriendshipsInitiator = await friendshipsRef
  .where('initiatorId', isEqualTo: userId)
  .where('status', isEqualTo: 'accepted')
  .get();

// Get friendships where user is recipient
final asFriendshipsRecipient = await friendshipsRef
  .where('recipientId', isEqualTo: userId)
  .where('status', isEqualTo: 'accepted')
  .get();

// Combine results
final allFriends = [
  ...asFriendshipsInitiator.docs,
  ...asFriendshipsRecipient.docs,
];
```

### Get pending friend requests received by a user

```dart
final pendingRequests = await friendshipsRef
  .where('recipientId', isEqualTo: userId)
  .where('status', isEqualTo: 'pending')
  .get();
```

### Check if two users are friends

```typescript
// Cloud Function (server-side)
async function areFriends(userA: string, userB: string): Promise<boolean> {
  const snapshot = await db.collection('friendships')
    .where('status', '==', 'accepted')
    .get();

  return snapshot.docs.some(doc => {
    const data = doc.data();
    return (
      (data.initiatorId === userA && data.recipientId === userB) ||
      (data.initiatorId === userB && data.recipientId === userA)
    );
  });
}
```

**Note**: For performance, this should be cached or use a denormalized `friendIds` array in user documents (see Story 11.6 for optimization).

## Performance Optimization

### Read Optimization (Story 11.6)

To minimize Firestore reads, consider:

1. **Caching**: Cache friend lists locally with TTL
2. **Denormalization**: Store `friendIds: string[]` in user documents
3. **Batch reads**: Fetch multiple friendships in single query

### Write Optimization

- Use `FieldValue.serverTimestamp()` for `createdAt` and `updatedAt`
- Batch writes when creating/updating multiple friendships
- Use transactions for status updates to prevent race conditions

## Data Model Classes

### FriendshipEntity (Domain Layer)

```dart
// lib/core/domain/entities/friendship_entity.dart
class FriendshipEntity {
  final String id;
  final String initiatorId;
  final String recipientId;
  final FriendshipStatus status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String initiatorName;
  final String recipientName;
}
```

### FriendshipModel (Data Layer)

```dart
// lib/core/data/models/friendship_model.dart
@freezed
class FriendshipModel with _$FriendshipModel {
  const factory FriendshipModel({
    required String id,
    required String initiatorId,
    required String recipientId,
    required FriendshipStatus status,
    @RequiredTimestampConverter() required DateTime createdAt,
    @RequiredTimestampConverter() required DateTime updatedAt,
    required String initiatorName,
    required String recipientName,
  }) = _FriendshipModel;

  factory FriendshipModel.fromJson(Map<String, dynamic> json);
  factory FriendshipModel.fromFirestore(DocumentSnapshot doc);
  Map<String, dynamic> toFirestore();
  FriendshipEntity toEntity();
}
```

## Example Data

```javascript
// Example 1: Pending friend request
{
  "initiatorId": "alice-uid-123",
  "recipientId": "bob-uid-456",
  "status": "pending",
  "createdAt": Timestamp(2024, 1, 15, 10, 0, 0),
  "updatedAt": Timestamp(2024, 1, 15, 10, 0, 0),
  "initiatorName": "Alice Smith",
  "recipientName": "Bob Jones"
}

// Example 2: Accepted friendship
{
  "initiatorId": "charlie-uid-789",
  "recipientId": "david-uid-012",
  "status": "accepted",
  "createdAt": Timestamp(2024, 1, 10, 14, 30, 0),
  "updatedAt": Timestamp(2024, 1, 11, 9, 15, 0),
  "initiatorName": "Charlie Brown",
  "recipientName": "David Miller"
}

// Example 3: Declined friendship (kept for audit)
{
  "initiatorId": "eve-uid-345",
  "recipientId": "frank-uid-678",
  "status": "declined",
  "createdAt": Timestamp(2024, 1, 12, 16, 45, 0),
  "updatedAt": Timestamp(2024, 1, 13, 8, 20, 0),
  "initiatorName": "Eve Wilson",
  "recipientName": "Frank Davis"
}
```

## Testing

### Unit Tests

- ✅ FriendshipModel serialization/deserialization
- ✅ FriendshipModel business logic methods
- ✅ Status transition validation
- ✅ Entity conversion (model ↔ entity)

See: `test/unit/core/data/models/friendship_model_test.dart`

### Integration Tests

(To be implemented in Story 11.9)

- Cloud Function: Send friend request
- Cloud Function: Accept friend request
- Cloud Function: Decline friend request
- Firestore Rules: Verify access control

## References

- **Epic 11**: #163
- **Story 11.1** (this story): #164 - Data Model
- **Story 11.2**: #165 - Cloud Functions
- **Story 11.3**: #166 - Triggers
- **Story 11.7**: #168 - Security Rules
- **Story 11.6**: #171 - Query Optimization

## Changelog

| Date | Story | Change |
|------|-------|--------|
| 2024-01-15 | 11.1 | Initial schema design and documentation |
